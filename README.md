## shTaskManager - легкий диспетчер задач для Arduino, основанный на системном таймере millis(). 

Библиотека позволяет организовать выполнение различных задач независимо друг от друга. 

- [Возможности библиотеки:](#возможности-библиотеки)
- [История версий](#история-версий)
- [Работа с библиотеками](#работа-с-библиотеками)
- [Остальные методы библиотеки:](#остальные-методы-библиотеки)

### Возможности библиотеки:

- Простое создание списка задач;
- Добавление новых и удаление существующих задач;
- Запуск, перезапуск, остановка и получение статуса любой задачи по ее идентификатору;
- Получение времени до срабатывания как ближайшей, так и конкретной задачи;
- Получение количества задач в списке;

### История версий

Версия 1.3 - 24.01.2025
+ добавлена возможность создания диспетчера без указания количества задач; в этом случае перед использованием диспетчера нужно вызвать метод `init()` с указанием количества;
+ добавлен метод `init(uint8_t _taskCount)`, который нужно вызвать перед заполнением списка задачами и указать максимальное количество задач в списке (если диспетчер был создан без указания количества задач);
* упорядочена документация методов библиотеки;
* подправлено выделение памяти под список задач - оказалось, что оператор `new` для массивов работает не на всех платах; в частности, проблема возникла на аддоне **Digistump AVR Boards** для платы **Digispark**));
+ добавлен контроль нулевого интервала задачи - задача, для которой задан интервал срабатывания равный нулю, считается неактивной;
* мелкие изменения и исправления;

Версия 1.2 - 06.11.2021
+ добавлен метод `getNextTaskPoint()`, возвращающий количество милисекунд до следующего срабатывания конкретной задачи; 

Версия 1.1 - 11.06.2021
+ добавлен метод `getTaskState()`, возвращающий данные об активности задачи; возвращает true если статус задачи "активна" и callback-функция для задачи назначена;
+ добавлен метод `setTaskState()`, позволяющий запускать или останавливать задачу с помощью флага;

Версия 1.0 - 08.06.2021

### Работа с библиотеками

При инициализации диспетчера задач сразу указывается максимальное количество задач, которые могут быть помещены в список. Например 2, если нужно управлять двумя светодиодами:

`shTaskManager tasks(2);`

Максимально возможное количество задач - 127, если МК с ними справится ))

Так же есть возможность создания диспетчера без указанием количества задач с инициализацией его позже; это может понадобиться, например, если количество задач зависит от параметров условной компиляции и не может быть заранее известно

`shTaskManager tasks;`

В этом случае перед заполнение списка задачами нужно вызвать метод `init(uint8_t _taskCount)` и указать максимальное количестов задач.

`tasks.init(2);`

Задачи добавляются в список с помощью метода:

`shHandle addTask(unsigned long _interval, shCallback _callback, bool isActive = true);`

где 
- `_interval` - интервал срабатывания задачи в милисекундах; если задать `_interval = 0`, задача будет считаться неактивной;
- `_callback` - имя функции, которая будет вызываться при срабатывании задачи (функция не должна принимать аргументы и возвращать значения);
- `isActive` - запускать или нет задачу в момент добавления;
- 
Метод вовращает идентификатор задачи (индекс задачи в списке), который позволяет обращаться к задаче для управления ею; если добавить задачу не удалось (например, список задач уже заполнен), метод вернет `-1`ю

Опрос списка задач выполняется методом:

`void tick();`

который нужно вызывать как можно чаще для надежного срабатывания задач.

### Остальные методы библиотеки:

`void delTask(shHandle _handle);` - удаление задачи из списка; `_handle` - идентификатор задачи;

`void startTask(shHandle _handle);` - запуск задачи; `_handle` - идентификатор задачи;

`void restartTask(shHandle _handle);` - перезапуск задачи; при перезапуске интервал срабатывания задачи начинает отсчитываться заново; `_handle` - идентификатор задачи;

`void stopTask(shHandle _handle);` - остановка задачи; `_handle` - идентификатор задачи;

`void taskExes(shHandle _handle);` - немедленное выполнение задачи; при этом если задача активна, то она будет перезапущена, ее интервал начнет заново отсчитываться с момента выполнения этого метода; `_handle` - идентификатор задачи;

`void setTaskInterval(shHandle _handle, unsigned long _interval, bool _restart = true);` - изменение интервала срабатывания задачи; 
- `_handle` - идентификатор задачи;
- `_interval` - новый интервал в милисекундах;
- `_restart` - перезапускать или нет задачу с новым интервалом;

`void setTaskState(shHandle _handle, bool _state);` - установка статуса задачи; 
- `_handle` - идентификатор задачи;
- `_state` - новый статус; 

в зависимости от значения флага `_state` будет вызван либо метод `startTask()` (при `_state == true`), либо метод `stopTask()` (при `_state == false`);

`bool getTaskState(shHandle _handle);` - получение текущего состояния задачи; возвращает **true**, если статус задачи "активна", задан ненулевой интервал срабатывания и callback-функция для задачи назначена; `_handle` - идентификатор задачи;

`unsigned long getNextPoint();` - получение времени в милисекундах до срабатывания следующей задачи; можно использовать, например, для погружения МК в сон на это время;

`unsigned long getNextTaskPoint(shHandle _handle);` - получение времени в милисекундах до следующего срабатывания задачи; `_handle` - идентификатор задачи;

`uint16_t getTaskCount(bool onlyActive = false);` - получение количества задач, помещенных в список; при `onlyActive == true` будет возвращено количество активных на данный момент задач, иначе - общее количество;

<hr>

Если возникнут вопросы, пишите на valesh-soft@yandex.ru 